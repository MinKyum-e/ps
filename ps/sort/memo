선택정렬(selection sort) - O(N^2)
:가장 작은 데이터를 선택해 맨 앞의 데이터와 바꾸고 , 그다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복

삽입정렬(insertion sort) - O(N^2), O(N)
:데이터를 하니씩 확인해서 적절한 위치에 삽입 (데이터가 거의 정렬되어있을때 효율적)
선택정렬 = 데이터 상태와 상관없이 무조건 모든 원소 확인  삽입정렬 : 적절한 위치에 들어가기전 앞의 모든 원소는 정렬되어있다고 생각함
삽입될 데이터보다 작은 데이터를 만나면 그 위치에 멈추면 됨

퀵정렬(Quick) : 무작위 데이터에서 NlogN 정렬된 데이터에선 N^2
:기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸자
기준 - 피벗, 리스트 분할방법 - 호어 분할 = 리스트에서 첫번째 데이터를 피벗으로 한다 + 왼쪽에서 피벗보다 큰 데이터를 찾고 오른쪽에서 작은데이터를 찾아서 교환\

0. 피벗 선택 후 데이터 찾아서 교환
1. 계속 반복
2. 오른쪽, 왼쪽에서 찾는 값의 위치가 엇갈린경우 작은 데이터와 피벗의 위치를 서로 변경
3. 분할완료 (피벗 보다 작은 데이터는 왼쪽, 큰 데이터는 오른쪽에 위치) : 파티션 
4. 왼쪽, 오른쪽 리스트를 각각 정렬

재귀 종료조건 : 현재 리스트의 데이터 개수가 1인경우


계수 정렬(count sort) - 시간, 공간 복잡도 O(N+k)
:특정 조건이 부합할때 사용가능(모든 데이터가 양의 정수, 데이터  개수: N , 최댓값 : K ======== O(N + K) 보장)
계수정렬은 데이터의 크기 법ㅁ위가 제한되어 정수로 표현할 수 있을 떄만 사용가능 (가장큰 수와 작은 수의 차이가 1,000,000 이하일 때 효과적) 이유 : 모든 범위를 담을 수 있는 크기의 리스트를 선언해야하기 떄문

1. 가장 큰 데이터와 가장작은 데이터의 범위가 모두 담길 수 있는 리스트 생성
2. 데이터 값과 동일한 인덱스의 데이터를 1씩 증가시키면 끝

기수 정렬(radix sort)
:계수정렬에 비해서는 느리지만 처리할 수 있는 정수의 크기는 더 크다

파이썬 기본 정렬
sorted() - 병합 정렬 기반. 최악의 경우에도 O(NlogN) 보장
리스트, 딕셔너리 정렬가능, 반환형은 리스트
리스트 변수가 하나 있을 때는 .sort()로 내부원소 정렬
key 매개변수 입력가능, key에는 하나의 함수가 들어가야하며 이는 정렬의 기준이된다


일반적으로는 기본 정렬을 사용하고 데이터 범위가 한정되어 있으며 빠르게 동작되어야하는 경우에는 계수 정렬을 사용하자

유형 
1. 정렬 라이브러리로 풀 수 있는 문제
2. 원리에 대해 물어보는 문제
3. 알고리즘 구조  개선 혹은 계수정렬 이용